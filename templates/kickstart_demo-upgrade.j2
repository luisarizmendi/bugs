lang en_US.UTF-8
keyboard us
timezone Etc/UTC --utc
zerombr
clearpart --all --initlabel
autopart --type=plain --fstype=xfs --nohome
text

network --bootproto=dhcp --device=link --activate --onboot=on

rootpw --iscrypted !$6$0XQkWnCyj3XZqA6F$MOHw/Sn3hec23mKjtxqGa.qnflkLb6FNR8s72yCsk.xVDoI35EOpgetjII/DkJVYrHVwF.ET3TLvVl7WYbMef0
user --name={{ builder_compose_customizations['user']['name'] }} --group=wheel,user
#sshkey --username={{ builder_compose_customizations['user']['name'] }} "{{ builder_pub_key }}"


## use local ostree
#ostreesetup --osname=rhel --url=file:///run/install/repo/ostree/repo --ref=rhel/9/x86_64/edge --nogpg
# use remote ostree
ostreesetup --nogpg --osname=rhel --remote=edge --url=http://{{ ansible_host }}/{{ builder_blueprint_name }}/repo/ --ref={{ builder_blueprint_ref }}

# reboot after installation is successfully completed
reboot --eject


############################################################################
################### GENERAL

%post  

# Include XDG_RUNTIME_DIR variable

XDG_RUNTIME_DIR=/run/user/$(grep admin /etc/passwd | awk -F : '{print $3}')
echo "export XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR" >> /var/home/admin/.bashrc


# fix ownership of user local files and SELinux contexts
chown -R admin: /var/home/admin
restorecon -vFr /var/home/admin




# sudo configuration for admin user
cat << EOF > /etc/sudoers.d/admin
admin    ALL=(ALL) NOPASSWD: ALL
EOF
#
%end


%post --nochroot --log=/mnt/sysimage/root/ks-post-serverless.log

hostnamectl set-hostname {{ system.hostname }}
hostnamectl --pretty set-hostname {{ system.hostname }}
cp /etc/hostname /mnt/sysimage/etc/hostname
cp /etc/machine-info /mnt/sysimage/etc/machine-info

%end




############################################################################
################### GREENBOOT


%post --log=/root/ks-post-greenboot.log

mkdir -p /etc/greenboot/check/required.d
cat > /etc/greenboot/check/required.d/01_check_git.sh <<EOF
#!/bin/bash

git --help

EOF

chmod +x /etc/greenboot/check/required.d/01_check_git.sh
%end





############################################################################
################### PODMAN AUTOUPDATE DEMO
%post --log=/root/ks-post-podman.log

set -x

# create systemd user directories for rootless services, timers, and sockets
mkdir -p /var/home/admin/.config/systemd/user/default.target.wants
mkdir -p /var/home/admin/.config/systemd/user/sockets.target.wants
mkdir -p /var/home/admin/.config/systemd/user/timers.target.wants
mkdir -p /var/home/admin/.config/systemd/user/multi-user.target.wants

cat > /var/home/admin/.config/systemd/user/podman-auto-update.service <<EOF
[Unit]
Description=Podman auto-update service
Documentation=man:podman-auto-update(1)

[Service]
ExecStart=/usr/bin/podman auto-update

[Install]
WantedBy=multi-user.target default.target
EOF



# This timer ensures podman auto-update is run every minute
cat > /var/home/admin/.config/systemd/user/podman-auto-update.timer <<EOF
[Unit]
Description=Podman auto-update timer

[Timer]
# This example runs the podman auto-update daily within a two-hour
# randomized window to reduce system load
#OnCalendar=daily
#Persistent=true
#RandomizedDelaySec=7200

# activate every minute
OnBootSec=30
OnUnitActiveSec=30

[Install]
WantedBy=timers.target
EOF


# define listener
node_ip=$(ip a show dev $(ip route | grep default | awk '{print $5}') | grep "inet " | awk '{print $2}' | awk -F / '{print $1}')

##
## Create a service to launch the container workload and restart
## it on failure
##
cat > /var/home/admin/.config/systemd/user/container-app1.service <<EOF
# container-app1.service
# autogenerated by Podman 4.2.0
# Wed Feb  8 10:13:55 UTC 2023

[Unit]
Description=Podman container-app1.service
Documentation=man:podman-generate-systemd(1)
Wants=network-online.target
After=network-online.target
RequiresMountsFor=%t/containers

[Service]
Environment=PODMAN_SYSTEMD_UNIT=%n
Restart=on-failure
TimeoutStopSec=70
ExecStartPre=/bin/rm -f %t/%n.ctr-id
ExecStart=/usr/bin/podman run \
        --cidfile=%t/%n.ctr-id \
        --cgroups=no-conmon \
        --rm \
        --sdnotify=conmon \
        -d \
        --replace \
        --name app1 \
        --label io.containers.autoupdate=registry \
        -p ${node_ip}:8081:8081 {{ apps.app1.registry }}/{{ apps.app1.image }}:{{ apps.app1.prodtag }}
ExecStop=/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-id
ExecStopPost=/usr/bin/podman rm -f --ignore --cidfile=%t/%n.ctr-id
Type=notify
NotifyAccess=all

[Install]
WantedBy=default.target
EOF


# enable connection through the firewall 
cat << EOF > /etc/systemd/system/expose-container-app1.service
[Unit]
Wants=firewalld.service
After=firewalld.service

[Service]
Type=oneshot
ExecStart=firewall-cmd --permanent --add-port=8081/tcp
ExecStartPost=firewall-cmd --reload

[Install]
WantedBy=multi-user.target default.target
EOF



# enable services
ln -s /var/home/admin/.config/systemd/user/podman-auto-update.timer /var/home/admin/.config/systemd/user/timers.target.wants/podman-auto-update.timer

ln -s /var/home/admin/.config/systemd/user/container-app1.service /var/home/admin/.config/systemd/user/default.target.wants/container-app1.service
ln -s /var/home/admin/.config/systemd/user/container-app1.service /var/home/admin/.config/systemd/user/multi-user.target.wants/container-app1.service

systemctl enable expose-container-app1.service



# fix ownership of user local files and SELinux contexts
chown -R admin: /var/home/admin
restorecon -vFr /var/home/admin


# enable linger so user services run whether user logged in or not
cat << EOF > /etc/systemd/system/enable-linger.service
[Service]
Type=oneshot
ExecStart=loginctl enable-linger admin

[Install]
WantedBy=multi-user.target default.target
EOF

systemctl enable enable-linger.service



%end



############################################################################
################### SERVERLESS DEMO

%post --log=/root/ks-post-serverless.log

set -x 

##
## Create a scale from zero systemd service for a container web
## server using socket activation
##

# create systemd user directories for rootless services, timers,
# and sockets
mkdir -p /var/home/admin/.config/systemd/user/default.target.wants
mkdir -p /var/home/admin/.config/systemd/user/sockets.target.wants
mkdir -p /var/home/admin/.config/systemd/user/timers.target.wants
mkdir -p /var/home/admin/.config/systemd/user/multi-user.target.wants



# define listener for socket activation
node_ip=$(ip a show dev $(ip route | grep default | awk '{print $5}') | grep "inet " | awk '{print $2}' | awk -F / '{print $1}')

cat << EOF > /var/home/admin/.config/systemd/user/container-httpd-proxy.socket
[Socket]
ListenStream=${node_ip}:8080
FreeBind=true

[Install]
WantedBy=sockets.target
EOF



# define proxy service that launches web container and forwards
# requests to it
cat << EOF > /var/home/admin/.config/systemd/user/container-httpd-proxy.service
[Unit]
Requires=container-httpd.service
After=container-httpd.service
Requires=container-httpd-proxy.socket
After=container-httpd-proxy.socket

[Service]
ExecStart=/usr/lib/systemd/systemd-socket-proxyd --exit-idle-time=10s 127.0.0.1:8080
EOF



##
## Create a service to launch the container workload and restart
## it on failure
##
cat > /var/home/admin/.config/systemd/user/container-httpd.service <<EOF
# container-httpd.service
# autogenerated by Podman 3.0.2-dev
# Thu May 20 10:16:40 EDT 2021

[Unit]
Description=Podman container-httpd.service
Documentation=man:podman-generate-systemd(1)
Wants=network-online.target
After=network-online.target
RequiresMountsFor=%t/containers
StopWhenUnneeded=true

[Service]
Environment=PODMAN_SYSTEMD_UNIT=%n
Restart=on-failure
TimeoutStopSec=70
ExecStartPre=/bin/rm -f %t/%n.ctr-id
ExecStart=/usr/bin/podman run --cidfile %t/%n.ctr-id --cgroups=no-conmon --sdnotify=conmon -d --replace --name httpd --label io.containers.autoupdate=registry -p 127.0.0.1:8080:8080 {{ apps.app2.registry }}/{{ apps.app2.image }}:{{ apps.app1.prodtag }}
ExecStop=/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-id
ExecStopPost=/usr/bin/podman rm -f --ignore --cidfile=%t/%n.ctr-id
Type=notify
NotifyAccess=all

[Install]
WantedBy=default.target
EOF





cat << EOF > /var/usrlocal/bin/pre-pull-container-image.sh
#!/bin/bash
while true
do 
  podman pull {{ apps.app2.registry }}/{{ apps.app2.image }}:{{ apps.app1.prodtag }}
  podman image list | grep {{ apps.app2.image }}
  if [ $? -eq 0 ]
  then 
    break
  fi  
done
EOF

chmod +x /var/usrlocal/bin/pre-pull-container-image.sh

# pre-pull the container images at startup to avoid delay in http response
cat > /var/home/admin/.config/systemd/user/pre-pull-container-image.service <<EOF
[Service]
Type=oneshot
ExecStart=/var/usrlocal/bin/pre-pull-container-image.sh

[Install]
WantedBy=multi-user.target default.target
EOF

# enable socket listener
ln -s /var/home/admin/.config/systemd/user/container-httpd-proxy.socket /var/home/admin/.config/systemd/user/sockets.target.wants/container-httpd-proxy.socket



# enable pre-pull container image
ln -s /var/home/admin/.config/systemd/user/pre-pull-container-image.service /var/home/admin/.config/systemd/user/default.target.wants/pre-pull-container-image.service
ln -s /var/home/admin/.config/systemd/user/pre-pull-container-image.service /var/home/admin/.config/systemd/user/multi-user.target.wants/pre-pull-container-image.service




# enable linger so user services run whether user logged in or not
cat << EOF > /etc/systemd/system/enable-linger.service
[Service]
Type=oneshot
ExecStart=loginctl enable-linger admin

[Install]
WantedBy=multi-user.target default.target
EOF

systemctl enable enable-linger.service

# enable 8080 port through the firewall to expose the application
cat << EOF > /etc/systemd/system/expose-container-app2.service
[Unit]
Wants=firewalld.service
After=firewalld.service

[Service]
Type=oneshot
ExecStart=firewall-cmd --permanent --add-port=8080/tcp
ExecStartPost=firewall-cmd --reload

[Install]
WantedBy=multi-user.target default.target
EOF



systemctl enable expose-container-app2.service


# fix ownership of user local files and SELinux contexts
chown -R admin: /var/home/admin
restorecon -vFr /var/home/admin


%end


























